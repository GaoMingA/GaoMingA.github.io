---
layout:     post
title:      "Java并发编程 (二)"
subtitle:   "线程的生命周期和线程控制"
navcolor:   "invert"
date:       2017-04-19
author:     "gaoming"
header-img: "/img/website/home-bg.jpg"
catalog: true
tags:
    - Java 
    - Thread 
---

# 线程生命周期

  了解了如何创建和启动线程后，直到线程死亡，中间都有哪些阶段呢，这就是线程的生命周期：**新建**(New)、**就绪**（Runnable）、**运行**（Running）、**阻塞**(Blocked)和**死亡**(Dead)**5种状态**，在任意时间段，一个线程有且只能有其中一种状态。

## 1. 新建

  当我们在编码时new一个Thread，此时线程便为新建状态，jvm为这个线程分配了内存，初始化成员变量，创建完成但还未启动。

## 2. 就绪

  线程对象调用了start()方法，此时，jvm为其创建了方法调用栈和程序计数器，但是这个状态还没有开始运行，何时开始运行，取决于jvm的调度。简单的可以理解为，线程已经启动了，但操作系统还没让线程执行，线程处在随时待命的状态，这就是就绪状态。

## 3. 运行

  理解了就绪状态，就可以很好的理解运行状态了，这个时候，操作系统给了就绪状态CPU资源，让其运行run()方法里面的任务，那么这个线程就属于运行状态了。

## 4. 阻塞

  处于运行状态的线程，在没有执行结束的情况下，操作系统或者程序员gg说让这个线程先别执行了，给别的线程执行，那么这个线程就暂停执行了，这时线程便处于阻塞状态。

  以上解释是为了方便理解，其实，阻塞状态是最复杂的一个状态，我个人更愿意将这个状态分成三个状态来理解（参考《深入理解java虚拟机》）：

### 4.1  无期限等待（Waiting）

  未设置Timeout的wait()方法，阻塞式IO方法。

  wait()方法将在线程控制一节做详细说明，线程在调用了这个方法后，会暂停执行，一直等待等待到notify()通知它可以执行后才会进入就绪状态，等待操作系统分配它cpu继续执行。简单理解了wait()方法后，我们就可以理解，为什么这种阻塞可以理解为无限期等待了。

### 4.2  期限等待（Timed Waiting）

  sleep()方法、设置了Timeout的wait()方法。

  线程调用sleep()方法，会主动放弃cpu资源，知道sleep的时间到了，它又会去争取cpu资源执行。可以看到，指定时间后该线程继续回到了就绪状态等待cpu给它执行的机会，所以这种情况可以叫做期限等待。

### 4.3 阻塞（Blocked）

  线程在等待一个排他锁的释放。

  排他锁有的地方也叫同步监视器monitor，这个我们会在线程安全一节详细介绍，排他锁的目的就是，将共享资源文件加个锁，这样的情况下，只有一个线程能获得该资源的使用，防止同一时间多个线程同时修改该资源导致的异常。当线程想要访问某个资源，而这个资源还未被解锁，就是说其他线程持有这个monitor，那么当前线程就被卡在这里不能继续执行了，这种状态便是Blocked。

  为什么我这里要将阻塞分成Waiting和Blocked呢，因为这样分类后阻塞状态我个人感觉比较明了，而且，后面涉及到线程死锁问题时会经常遇到阻塞概念，引起死锁的阻塞状态就是这里的Blocked而不是Waiting。

## 5. 死亡

  顾名思义，线程结束，就是这个状态。结束线程的几种情况如下（摘自wikipedia）：

1. 最简单的情况是，Thread/Runnable的run()方法运行完毕，自行终止。
2. 对于更复杂的情况，比如有循环，则可以增加终止标记变量和任务终止的检查点。
3. 最常见的情况，也是为了解决阻塞不能执行检查点的问题，用中断来结束线程，但中断只是请求，并不能完全保证线程被终止，需要执行线程协同处理。
4. IO阻塞和等锁情况下需要通过特殊方式进行处理。
5. 使用Future类的cancel()方法调用。
6. 调用线程池执行器的shutdown()和shutdownNow()方法。
7. 守护线程会在非守护线程都结束时自动终止。

  了解了线程生命周期各个状态概念后，再来看看各个状态之间是怎么样一个切换过程呢，其实最关键的就是阻塞状态和运行状态之间的转换。

![线程生命周期转换图](https://github.com/GaoMingA/blogger/blob/master/img/android/java_thread_lifecycle.png?raw=true)

> 注：线程死亡后就不能再尝试启动线程了，可以通过isAlive()方法判断线程状态，当线程处于新建和死亡状态时返回false，如果尝试启动已经死亡的线程，程序会抛出IllegalThreadStateException异常。

# 线程控制

  前面线程生命周期里面在线程状态转换时用到了很多方法，比如sleep() wait()等等，这些方法可以控制线程的执行状态的切换，所以我们这一节主要看看线程控制的这些方法，可以自己写demo调用这些方法，查看执行结果对比下表中的功能说明列来加深这些控制方法的理解。

| 线程控制方法        | 功能                                       |
| :------------ | :--------------------------------------- |
| join()        | 在Thread1里面执行Thread2.join(),那么Thread1进入Waiting状态，要等Thread2执行完后才能继续执行 |
| sleep()       | Thread1.sleep(long millis) 执行线程Thread1进入Waiting状态，等待millis毫秒后再执行 |
| yield()       | 从上面的状态转换图可以看到，运行状态的线程调用了yield()方法后，直接进入了就绪状态，也就是说，调用了这个方法后，线程让步一次，然后由操作系统再分配资源，有可能其他线程先运行也有可能该线程继续获得运行权 |
| setPriority() | Thread.setPriority(int newPriority)设置线程的优先级，优先级由1-10依次增高，Thread提供了三个静态常量可以使用： public static final int MIN_PRIORITY = 1; public static final int NORM_PRIORITY = 5; public static final int MAX_PRIORITY = 10;  getPriority()可以获取线程的优先级 |
| Daemon        | 守护线程，Thread.setDaemon(true)，程序没有其他线程只有守护线程，守护线程是无法存活的，不管它有没有执行结束 |

# 总结

  了解线程的生命周期，有助于编码时更好的控制线程，简单介绍几种常用的线程控制方法，细心的可能发现，让线程进入阻塞的wait()方法没有列在表格中，wait()方法其实是配合notify()方法来控制不同的线程进行交互的，所以将在线程通信一节来说明。

